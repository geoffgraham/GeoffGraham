{
  "name": "streamer",
  "id": "streamer",
  "version": "0.2.1",
  "description": "Asynchronously recursive, pure function <3 via lazy streams.",
  "keywords": [
    "stream",
    "functional",
    "spaghetti",
    "lazy",
    "iteration",
    "async"
  ],
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com"
  },
  "homepage": "https://github.com/Gozala/streamer",
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/streamer.git",
    "web": "https://github.com/Gozala/streamer"
  },
  "bugs": {
    "url": "http://github.com/Gozala/streamer/issues/"
  },
  "devDependencies": {
    "test": ">=0.2.0"
  },
  "main": "./core.js",
  "scripts": {
    "test": "node tests/test-streamer.js"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://jeditoolkit.com/LICENSE"
    }
  ],
  "readme": "/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true devel: true\n         forin: true latedef: false globalstrict: true */\n/*global define: true setInterval: true */\n\n/* html version: http://jeditoolkit.com/streamer/docs/readme.html */\n\n'use strict';\n\n// In computing, the term stream is used in a number of ways, in all cases\n// referring to a sequence of elements made available over time.\n\n\n// Let's create a very basic stream representing a sequence of elements\n// from 1 to 3.\n\nfunction stream(next) {\n  [ 1, 2, 3 ].forEach(function(element) {\n    next(element)\n  })\n}\n\n// From this example we can define a stream as:\n// a function representing a sequence of elements. It can be read by calling\n// with one function argument, which will be called back with each element of\n// the sequence.\n\n// So we can print our stream like this:\nstream(function onEach(element) {\n  console.log(element)\n})\n\n//      1\n//      2\n//      3\n\n// Or, we can create a convenience\n// [high-order function](http://en.wikipedia.org/wiki/Higher-order_function)\n// for printing streams.\n\nfunction print(stream) {\n  stream(function onEach(element) {\n    console.log(element)            // Print each element of the sequence.\n  })\n}\n\n// And, print stream with it:\nprint(stream)\n\n//      1\n//      2\n//      3\n\n// Good, but!\n// Stream is a sequence of elements **made available over time**.\n// In other words a sequence may be lazy, and our stream definition needs\n// refinement:\n//\n// Stream is a function representing a sequence of elements. It MAY be read by\n// calling it with one function argument, that will be called back with each\n// element when it becomes available.\n\n// Let's create a function `numbers`, that takes `min` and\n// `max` numbers and returns a lazy stream of random numbers in a given range.\n// To make the stream lazy, we will make its new elements available every 20ms.\nfunction numbers(min, max) { // Another high-order function to make streams\n  var delta = max - min\n  return function stream(next) { // Actual stream that generates \n    setInterval(function generate() {\n      // We yield a random number in given range every 20ms.\n      next(min + Math.round(Math.random() * delta))\n    }, 20)\n  }\n}\n\n// Make a stream of random numbers in the 0 - 100 range.\nvar numberStream = numbers(0, 100)\n// And we print it!!\nprint(numberStream)\n\n//      29\n//      33\n//      45\n//      ....\n\n// Oops! The stream keeps printing these numbers infinitely. Right, that's because\n// a stream is infinite! So we may have finite and infinite streams, the difference\n// being that finite streams end / stop at some point. And if a stream stops we need\n// to know when that happens. To do that we will add a second, optional `stop`\n// callback argument that MUST be called once stream reaches its end. Let's\n// redefine our `print` function with this in mind:\n\nfunction print(stream) {\n  console.log(\">>>\")                    // Opening stream for reading\n  stream(function onElement(element) {\n    console.log(element)                // Print each element of stream.\n  }, function onStop() {\n    console.log(\"<<<\")                  // Stream is stopped.\n  })\n}\n\n// Now we need a stream to print. Instead of creating another basic stream,\n// this time we will take more generic approach by defining a function that\n// takes an array as an argument and returns a stream of its elements:\n\nfunction list(array) {\n  return function stream(next, stop) {\n    array.forEach(function(element) {\n      next(element)\n    })\n    stop()\n  }\n}\n\n// Great let's print something now!\n\nprint(list(1, 2, 3))\n\n// Right, we should have passed an array to the list. Yeah, so shit happens! And\n// when it happens to the stream, it needs to do something about it. The only\n// reasonable thing is to recover, and if that is not possible then stop and\n// report the reason of failure. This means that the `stop` callback MAY be called\n// with an error argument, indicating a reason of failure!\n\n// Let's adjust our print and streams to do that:\n\nfunction print(stream) {\n  console.log(\">>>\")                      // Opening stream for reading\n  stream(function onElement(element) {\n    console.log(element)                  // Print each element of stream.\n  }, function onStop(error) {\n    if (!error) return console.log('<<<') // If no error is passed, stream ended\n    // If there is an error print it out as well.\n    console.log('!!!')\n    console.error(error)\n  })\n}\n\n// Let's make another version of a function that returns a stream of given\n// elements, in this case though we will use arguments instead of requiring\n// an array argument.\nfunction list() {\n  // Capture arguments as an array.\n  var elements = Array.prototype.slice.call(arguments, 0)\n  // Stream takes two callback arguments, the first is called with each element\n  // when it becomes available, and the second after calling first with all the\n  // elements of the stream.\n  return function stream(next, stop) {\n    // Yield each element of the stream by calling the `next`. callback.\n    elements.forEach(function(element) {\n      next(element)\n    })\n    // When we reach the end we stop a stream by calling the `stop` callback\n    // if it's passed.\n    if (stop) stop()\n  }\n}\n\n// Another attempt to print:\nprint(list(1, 2, 3))\n\n//      >>>\n//      1\n//      2\n//      3\n//      <<<\n\n// Let's refine our stream definition again:\n\n// _Stream is a function representing a sequence of elements. It MAY be read by\n// calling it with one function argument, that will be called every time an element\n// becomes available. Stream takes a second optional function argument which\n// is called once the stream is stopped, either without arguments when stream runs\n// out of elements or with an error indicating the failure reason indicating why\n// stream was stopped._\n\n// Let's do something interesting from real life, like create a stream of all\n// directory entries including entries from all nested directories (lstree).\n//\n// First we will have to create a few stream based wrappers around node's fs\n// functions. We will start with a function that takes the path for a directory\n// and returns a lazy stream of its entries. If reading a directory fails we\n// will stop the stream with an error:\n\nvar fs = require(\"fs\")\nfunction ls(path) {\n  return function stream(next, stop) {\n    //see: [http://nodejs.org/docs/v0.4.8/api/fs.html#fs.readdir](http://nodejs.org/docs/v0.4.8/api/fs.html#fs.readdir)\n    fs.readdir(path, function onEntries(error, entries) {\n      var entry\n      // On error we stop a stream with that error.\n      if (error) return stop(error)\n      // Otherwise we yield each entry.\n      while ((entry = entries.shift())) next(entry)\n      // Once we yielded all entries we stop a stream.\n      stop()\n    })\n  }\n}\n\n// Try it out for the current working directory:\nprint(ls('./'))\n\n//      >>>\n//      .gitignore\n//      History.md\n//      package.json\n//      readme.js\n//      Readme.md\n//      streamer.js\n//      tests\n//      <<<\n\n// The next wrapper we will need is `fs.stat`. We define a function that `takes`\n// a path and returns a lazy stream with only an element representing `stat` of\n// the given `path`. A lazy steam with one element can been seen as a promise\n// or deferred, but don't worry if you are not familiar with that pattern.\nfunction stat(path) {\n  return function stream(next, stop) {\n    //see: [http://nodejs.org/docs/v0.4.8/api/fs.html#fs.stat](http://nodejs.org/docs/v0.4.8/api/fs.html#fs.stat)\n    fs.stat(path, function onStat(error, stats) {\n      // On error we stop the stream with that error.\n      if (error) return stop(error)\n      // We add the path to the stat itself as it will be very convenient.\n      stats.path = path\n      // We yield `stats` and stop the stream.\n      next(stats)\n      stop()\n    })\n  }\n}\n\n// Try it out for the current working directory:\nprint(stat('./'))\n\n//      >>>\n//      { dev: 234881026,\n//      ino: 19933437,\n//      mode: 16877,\n//      nlink: 17,\n//      uid: 502,\n//      gid: 20,\n//      rdev: 0,\n//      size: 578,\n//      blksize: 4096,\n//      blocks: 0,\n//      atime: Thu, 09 Jun 2011 10:51:25 GMT,\n//      mtime: Thu, 09 Jun 2011 12:48:32 GMT,\n//      ctime: Thu, 09 Jun 2011 12:48:32 GMT,\n//      path: './' }\n//      <<<\n\n// Great we are done with the wrappers. Now we can list entries of the directory,\n// but in order to list nested entries we need to distinguish directories\n// from files. To do that we will create a function that takes a directory entries\n// stream and returns a filtered stream containing only entries that are\n// directories. We already can get stats from paths, so we just need to map entry\n// paths to stats. Let's make a generic map function that takes a stream and a\n// mapper function and returns a stream of mapped elements.\n\nfunction map(lambda, source) {\n  return function stream(next, stop) {\n    source(function onElement(element) {\n      next(lambda(element))\n    }, stop)\n  }\n}\n\n// Let's try to map numbers into doubled values:\nprint(map(function(x) { return x * 2 }, list(1, 2, 3)))\n\n//      >>>\n//      2\n//      4\n//      6\n//      <<<\n\n// Now we can implement a function that is the equivalent of `ls` with the\n// difference that it returns a stream of paths instead of entry filenames.\n\nvar join = require(\"path\").join\nfunction paths(path) { return map(join.bind(null, path), ls(path)) }\n\n// Test drive:\nprint(paths(process.cwd()))\n\n//      >>>\n//      /Users/gozala/Projects/streamer/History.md\n//      /Users/gozala/Projects/streamer/package.json\n//      ...\n//      <<<\n\n// Now we need another equivalent of `paths` that returns a stream of directory\n// paths only. To do that we need to filter out directories. So let's implement\n// a generic filter function that takes a stream of elements and a filter function\n// and returns the steam of elements for which the filterer returned true.\nfunction filter(lambda, source) {\n  return function stream(next, stop) {\n    source(function onElement(element) {\n      if (lambda(element)) next(element)\n    }, stop)\n  }\n}\n// Simple example for filtering out odd numbers from a number stream.\nprint(filter(function(x) { return x % 2 }, list(1, 2, 3, 4)))\n\n//      >>>\n//      1\n//      3\n//      <<<\n\n// Awesome, going back to our problem, to figure out weather we have a file\n// path or directory path we need to map paths to stats and then filter out\n// only ones from there that are directories:\nfunction dirs(paths) { \n  var stats = map(stat, paths)\n  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)\n  return map(function(stat) { return stat.path }, dirStats)\n}\n\n// Unfortunately dirs not going to work, because the `stats` stream is not\n// a stream of `stat` elements, it is a stream of streams that are streams of\n// `stat` elements. So what we need is sort of a flattened version of that stream.\n// This is easy to do with another core `merge` function:\nfunction merge(source) {\n  return function stream(next, stop) {\n    var open = 1\n    function onStop(error) {\n      if (!open) return false\n      if (error) open = 0\n      else open --\n\n      if (!open) stop(error)\n    }\n    source(function onStream(stream) {\n      open ++\n      stream(function onNext(value) { if (open) next(value) }, onStop)\n    }, onStop)\n  }\n}\n\n// Let's try a simple example:\nprint(merge(list(list(1, 2), list('a', 'b'))))\n\n//      >>>\n//      1\n//      2\n//      a\n//      b\n//      <<<\n\n// Now we can refine our dirs function:\nfunction dirs(paths) {\n  var stats = merge(map(paths, stat))\n  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)\n  return map(function(stat) { return stat.path }, dirStats)\n}\n\n// Test drive:\nprint(dirs(paths(process.cwd())))\n\n//      >>>\n//      /Users/gozala/Projects/streamer/.git\n//      /Users/gozala/Projects/streamer/node_modules\n//      ...\n//      <<<\n//\n\n// Finally we have all we need to implement `lstree`:\nfunction lstree(path) {\n  var entries = paths(path)\n  var nested = merge(map(lstree, dirs(entries)))\n  return merge(list(entries, nested))\n}\n\n// Crossing our fingers!!\nprint(lstree('./'))\n//\n//      >>>\n//      .git\n//      .git/COMMIT_EDITMSG\n//      .git/config\n//      ....\n//      <<<\n//\n\n// So let's take a look back now, if we ignore all the core stream functions\n// that are part of the [streamer library](https://github.com/Gozala/streamer) and\n// some node `fs` wrappers, we have written code that deals with recursive\n// asynchronous code, but that has a very linear flow. Take another\n// look at it with all the noise removed:\n\nfunction paths(path) { return map(join.bind(null, path), ls(path)) }\nfunction dirs(paths) { \n  var stats = map(stat, paths)\n  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)\n  return map(function(stat) { return stat.path }, dirStats)\n}\nfunction lstree(path) {\n  var entries = paths(path)\n  var nested = merge(map(lstree, dirs(entries)))\n  return merge(list(entries, nested))\n}\n\n// Feel free to take a look at another example of using [streams in browser]\n// (http://jeditoolkit.com/streamer/demos/axis.html). Or discover even more\n// utility functions [in the source](https://github.com/Gozala/streamer/blob/master/streamer.js)\n",
  "readmeFilename": "readme.js",
  "_id": "streamer@0.2.1",
  "_from": "streamer@0.2.x"
}
